---
layout: archive
title: "boost::asio"
modified:
categories: c++
excerpt: "c++에서 비동기, non blocking 방식의 통신을 알아보자."
tags: [c++]
---

### Synchronous, Asynchronous
 동기는 요청과 결과가 동시에 일어나는 것, 즉 함수를 호출하고 그 결과를 호출한 쪽에서 처리하는 것이다. 반대로 비동기는 요청과 결과가 동시에 일어나지 않는다.

  동기는 설계 방식이 간단하고 직관적이지만 한번 함수를 호출하면 그 함수의 수행이 끝날때까지 기다려야한다는 단점이 있다. 함수의 수행이 끝날때까지 아무것도 하지 못하기 때문에 비동기 방식보다 느릴 수 있다. 비동기는 동기보다 설계 방식이 복잡하지만 함수 호출 후 다른 작업을 수행할 수 있기 때문에 동기 방식보다 자원을 효율적으로 활용하게 된다.

### Blocking, Non-Blocking
 Blocking은 단어의 뜻 그대로 멈춘다는 의미를 가진다. 함수 수행이 끝날때까지 제어권은 그 함수가 가지는 것이다. non-blocking은 함수가 호출될때 제어권은 바로 caller에게 넘기며, 본인의 함수 수행이 진행되는 순간에도 caller에서 다른 일을 할 수 있도록 한다.

### Socket 통신
 c++에서 흔히 통신으로 사용하는 것이 socket이다. socket은 read/write 함수로 서로 정보를 주고받는데, client에서 서버로 write하고 답을 기다리기 위해 read를 호출하면 server에서 답이 올때까지 client는 blocking 상태에 있게 된다.
통신 설계상 그것이 문제가 없을 경우도 있겠지만 흔히 사용하는 카카오톡과 같은 채팅을 구현하기 위해서는 위의 상황과는 조금 다른 상황을 고려해야 할것이다.
 카카오톡을 사용해 본 사용자들은 알테지만, 내가 누군가에게 메세지를 보내고 그 누군가에게서 다시 메세지가 올때까지 기다리며 메세지를 못보내지 않는다. 즉 메세지를 보내는 것과 받는것은 따로 움직여야하는 것이다. 그것 뿐이랴 채팅방을 구현하려고 한다면 다중채팅을 구현해야한다. 방을 구성하는 서버는 한대인데, 채팅방에 참여하는 사용자는 여러명이 되는 상황이 펼쳐지는 것이다.
  가장 기본적으로 해결해야하는 것은 read할때 blocking되는 상황이다. 사실 멀티쓰레드를 사용하면 못할 것도 없지만 boost에 asio라는 것이 있다. 이를 이용하면 non-blocking하게 비동기 통신을 할 수 있게 된다.

### boost::asio
 asio는 boost 라이브러리의 일부로 네트워크 프로그래밍에서 주로 사용된다. I/O와 같이 시간이 걸리는 처리를 OS의 비동기 기능과 쓰레드를 함께 사용해서 처리한다. 네트워크가 아니라도 파일 입출력이나 시리얼 입출력, 일반적인 비동기 프로그래밍에서도 사용된다. 또한 멀티 플랫폼을 지원하기 때문에 리눅스, 윈도우, 맥에 상관없이 사용 가능하다.

#### IO Service 클래스
 asio에서는 IO Service라는 클래스가 핵심적인 역할을 수행한다. 커널에서 발생하는 입출력 이벤트를 우선순위가 높은 작업이 우선적으로 수행될 수 있도록 시스템 자원을 할당해주는 역할을 수행한다. 

#### EndPoint
IP 주소와 port번호의 쌍

#### Acceptor
 서버가 IO Service와 EndPoint를 이용해 클라이언트의 접속을 받아들이는 기능을 수행, 구체적으로 말하자면 수동켓을 만드는 일을 한다. 수동소켓은 "연결 수립 요청을 기다리는 소켓"이다.
반대로 능동소켓이라는 것이 있는데 이는 다른 컴퓨터에 데이터를 보내거나 데이터를 받아오기 위해 사용하는 소켓이다.

#### 비동기 방식으로 사용하기
 asio를 이용해서 동기, 비동기 모두 구현할 수 있다. 비동기 구현만 설명하자면 여러가지 콜백함수를 만들어서 사용하는 방식이다. read, accept, write등의 이벤트가 발생하였을때 지정해놓은 콜백함수가 수행되는 식으로 동작한다.
